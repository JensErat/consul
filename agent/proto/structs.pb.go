// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: structs.proto

package proto

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// RaftIndex is used to track the index used while creating
// or modifying a given struct type.
type RaftIndex struct {
	CreateIndex uint64 `protobuf:"varint,1,opt,name=CreateIndex,proto3" json:"CreateIndex,omitempty" bexpr:"-"`
	ModifyIndex uint64 `protobuf:"varint,2,opt,name=ModifyIndex,proto3" json:"ModifyIndex,omitempty" bexpr:"-"`
}

func (m *RaftIndex) Reset()         { *m = RaftIndex{} }
func (m *RaftIndex) String() string { return proto.CompactTextString(m) }
func (*RaftIndex) ProtoMessage()    {}
func (*RaftIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{0}
}
func (m *RaftIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftIndex.Merge(m, src)
}
func (m *RaftIndex) XXX_Size() int {
	return m.Size()
}
func (m *RaftIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftIndex.DiscardUnknown(m)
}

var xxx_messageInfo_RaftIndex proto.InternalMessageInfo

type WriteRequest struct {
	// Token is the ACL token ID. If not provided, the 'anonymous'
	// token is assumed for backwards compatibility.
	Token string `protobuf:"bytes,1,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *WriteRequest) Reset()         { *m = WriteRequest{} }
func (m *WriteRequest) String() string { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()    {}
func (*WriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{1}
}
func (m *WriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteRequest.Merge(m, src)
}
func (m *WriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *WriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WriteRequest proto.InternalMessageInfo

// QueryOptions is used to specify various flags for read queries
type QueryOptions struct {
	// Token is the ACL token ID. If not provided, the 'anonymous'
	// token is assumed for backwards compatibility.
	Token string `protobuf:"bytes,1,opt,name=Token,proto3" json:"Token,omitempty"`
	// If set, wait until query exceeds given index. Must be provided
	// with MaxQueryTime.
	MinQueryIndex uint64 `protobuf:"varint,2,opt,name=MinQueryIndex,proto3" json:"MinQueryIndex,omitempty"`
	// Provided with MinQueryIndex to wait for change.
	MaxQueryTime time.Duration `protobuf:"bytes,3,opt,name=MaxQueryTime,proto3,stdduration" json:"MaxQueryTime"`
	// If set, any follower can service the request. Results
	// may be arbitrarily stale.
	AllowStale bool `protobuf:"varint,4,opt,name=AllowStale,proto3" json:"AllowStale,omitempty"`
	// If set, the leader must verify leadership prior to
	// servicing the request. Prevents a stale read.
	RequireConsistent bool `protobuf:"varint,5,opt,name=RequireConsistent,proto3" json:"RequireConsistent,omitempty"`
	// If set, the local agent may respond with an arbitrarily stale locally
	// cached response. The semantics differ from AllowStale since the agent may
	// be entirely partitioned from the servers and still considered "healthy" by
	// operators. Stale responses from Servers are also arbitrarily stale, but can
	// provide additional bounds on the last contact time from the leader. It's
	// expected that servers that are partitioned are noticed and replaced in a
	// timely way by operators while the same may not be true for client agents.
	UseCache bool `protobuf:"varint,6,opt,name=UseCache,proto3" json:"UseCache,omitempty"`
	// If set and AllowStale is true, will try first a stale
	// read, and then will perform a consistent read if stale
	// read is older than value.
	MaxStaleDuration time.Duration `protobuf:"bytes,7,opt,name=MaxStaleDuration,proto3,stdduration" json:"MaxStaleDuration"`
	// MaxAge limits how old a cached value will be returned if UseCache is true.
	// If there is a cached response that is older than the MaxAge, it is treated
	// as a cache miss and a new fetch invoked. If the fetch fails, the error is
	// returned. Clients that wish to allow for stale results on error can set
	// StaleIfError to a longer duration to change this behavior. It is ignored
	// if the endpoint supports background refresh caching. See
	// https://www.consul.io/api/index.html#agent-caching for more details.
	MaxAge time.Duration `protobuf:"bytes,8,opt,name=MaxAge,proto3,stdduration" json:"MaxAge"`
	// MustRevalidate forces the agent to fetch a fresh version of a cached
	// resource or at least validate that the cached version is still fresh. It is
	// implied by either max-age=0 or must-revalidate Cache-Control headers. It
	// only makes sense when UseCache is true. We store it since MaxAge = 0 is the
	// default unset value.
	MustRevalidate bool `protobuf:"varint,9,opt,name=MustRevalidate,proto3" json:"MustRevalidate,omitempty"`
	// StaleIfError specifies how stale the client will accept a cached response
	// if the servers are unavailable to fetch a fresh one. Only makes sense when
	// UseCache is true and MaxAge is set to a lower, non-zero value. It is
	// ignored if the endpoint supports background refresh caching. See
	// https://www.consul.io/api/index.html#agent-caching for more details.
	StaleIfError time.Duration `protobuf:"bytes,10,opt,name=StaleIfError,proto3,stdduration" json:"StaleIfError"`
	// Filter specifies the go-bexpr filter expression to be used for
	// filtering the data prior to returning a response
	Filter string `protobuf:"bytes,11,opt,name=Filter,proto3" json:"Filter,omitempty"`
}

func (m *QueryOptions) Reset()         { *m = QueryOptions{} }
func (m *QueryOptions) String() string { return proto.CompactTextString(m) }
func (*QueryOptions) ProtoMessage()    {}
func (*QueryOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{2}
}
func (m *QueryOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryOptions.Merge(m, src)
}
func (m *QueryOptions) XXX_Size() int {
	return m.Size()
}
func (m *QueryOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryOptions.DiscardUnknown(m)
}

var xxx_messageInfo_QueryOptions proto.InternalMessageInfo

// QueryMeta allows a query response to include potentially
// useful metadata about a query
type QueryMeta struct {
	// This is the index associated with the read
	Index uint64 `protobuf:"varint,1,opt,name=Index,proto3" json:"Index,omitempty"`
	// If AllowStale is used, this is time elapsed since
	// last contact between the follower and leader. This
	// can be used to gauge staleness.
	LastContact time.Duration `protobuf:"bytes,2,opt,name=LastContact,proto3,stdduration" json:"LastContact"`
	// Used to indicate if there is a known leader node
	KnownLeader bool `protobuf:"varint,3,opt,name=KnownLeader,proto3" json:"KnownLeader,omitempty"`
	// Consistencylevel returns the consistency used to serve the query
	// Having `discovery_max_stale` on the agent can affect whether
	// the request was served by a leader.
	ConsistencyLevel string `protobuf:"bytes,4,opt,name=ConsistencyLevel,proto3" json:"ConsistencyLevel,omitempty"`
}

func (m *QueryMeta) Reset()         { *m = QueryMeta{} }
func (m *QueryMeta) String() string { return proto.CompactTextString(m) }
func (*QueryMeta) ProtoMessage()    {}
func (*QueryMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_e774e8f5f348d14d, []int{3}
}
func (m *QueryMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMeta.Merge(m, src)
}
func (m *QueryMeta) XXX_Size() int {
	return m.Size()
}
func (m *QueryMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMeta.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMeta proto.InternalMessageInfo

func init() {
	proto.RegisterType((*RaftIndex)(nil), "proto.RaftIndex")
	proto.RegisterType((*WriteRequest)(nil), "proto.WriteRequest")
	proto.RegisterType((*QueryOptions)(nil), "proto.QueryOptions")
	proto.RegisterType((*QueryMeta)(nil), "proto.QueryMeta")
}

func init() { proto.RegisterFile("structs.proto", fileDescriptor_e774e8f5f348d14d) }

var fileDescriptor_e774e8f5f348d14d = []byte{
	// 506 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x52, 0xc1, 0x6e, 0xd3, 0x4a,
	0x14, 0xb5, 0xdf, 0x4b, 0x42, 0x7c, 0x93, 0xa0, 0x32, 0xaa, 0xd0, 0x90, 0xc5, 0x24, 0xb2, 0x2a,
	0x14, 0x21, 0x48, 0x24, 0xd8, 0xc1, 0xaa, 0x09, 0x05, 0x55, 0xc4, 0xaa, 0x18, 0x8a, 0x58, 0x4f,
	0x92, 0x1b, 0x63, 0xe1, 0x7a, 0xc2, 0x78, 0xdc, 0x3a, 0x7f, 0xc1, 0x82, 0x45, 0xbf, 0x84, 0x6f,
	0xc8, 0xb2, 0x4b, 0x56, 0x05, 0x92, 0x3f, 0xe0, 0x0b, 0x90, 0xc7, 0x69, 0xe5, 0x92, 0x2e, 0xc2,
	0xca, 0x73, 0x8e, 0xcf, 0x99, 0x7b, 0xe7, 0xde, 0x03, 0x8d, 0x58, 0xab, 0x64, 0xac, 0xe3, 0xee,
	0x4c, 0x49, 0x2d, 0x49, 0xd9, 0x7c, 0x9a, 0xcc, 0x97, 0xd2, 0x0f, 0xb1, 0x67, 0xd0, 0x28, 0x99,
	0xf6, 0x26, 0x89, 0x12, 0x3a, 0x90, 0x51, 0x2e, 0x6b, 0xee, 0xfa, 0xd2, 0x97, 0xe6, 0xd8, 0xcb,
	0x4e, 0x39, 0xeb, 0x9e, 0x80, 0xc3, 0xc5, 0x54, 0x1f, 0x46, 0x13, 0x4c, 0x49, 0x0f, 0x6a, 0x03,
	0x85, 0x42, 0xa3, 0x81, 0xd4, 0x6e, 0xdb, 0x9d, 0x52, 0xbf, 0xf1, 0xfb, 0xb2, 0xe5, 0x8c, 0x30,
	0x9d, 0xa9, 0xe7, 0xee, 0x13, 0x97, 0x17, 0x15, 0x99, 0xc1, 0x93, 0x93, 0x60, 0x3a, 0xcf, 0x0d,
	0xff, 0xdd, 0x6a, 0x28, 0x28, 0xdc, 0x3d, 0xa8, 0x7f, 0x50, 0x81, 0x46, 0x8e, 0x9f, 0x13, 0x8c,
	0x35, 0xd9, 0x85, 0xf2, 0xb1, 0xfc, 0x84, 0x91, 0xa9, 0xe5, 0xf0, 0x1c, 0xb8, 0x5f, 0x4b, 0x50,
	0x7f, 0x9b, 0xa0, 0x9a, 0x1f, 0xcd, 0xb2, 0x07, 0xc4, 0xb7, 0xcb, 0xc8, 0x1e, 0x34, 0xbc, 0x20,
	0x32, 0xc2, 0x42, 0x7d, 0x7e, 0x93, 0x24, 0xaf, 0xa1, 0xee, 0x89, 0xd4, 0x10, 0xc7, 0xc1, 0x09,
	0xd2, 0xff, 0xdb, 0x76, 0xa7, 0xf6, 0xf4, 0x41, 0x37, 0x1f, 0x57, 0xf7, 0x6a, 0x5c, 0xdd, 0x97,
	0xeb, 0x71, 0xf5, 0xab, 0x8b, 0xcb, 0x96, 0x75, 0xfe, 0xa3, 0x65, 0xf3, 0x1b, 0x46, 0xc2, 0x00,
	0xf6, 0xc3, 0x50, 0x9e, 0xbd, 0xd3, 0x22, 0x44, 0x5a, 0x6a, 0xdb, 0x9d, 0x2a, 0x2f, 0x30, 0xe4,
	0x31, 0xdc, 0xcb, 0x9e, 0x15, 0x28, 0x1c, 0xc8, 0x28, 0x0e, 0x62, 0x8d, 0x91, 0xa6, 0x65, 0x23,
	0xdb, 0xfc, 0x41, 0x9a, 0x50, 0x7d, 0x1f, 0xe3, 0x40, 0x8c, 0x3f, 0x22, 0xad, 0x18, 0xd1, 0x35,
	0x26, 0x47, 0xb0, 0xe3, 0x89, 0xd4, 0xdc, 0x7a, 0xd5, 0x15, 0xbd, 0xb3, 0x7d, 0xdb, 0x1b, 0x66,
	0xf2, 0x02, 0x2a, 0x9e, 0x48, 0xf7, 0x7d, 0xa4, 0xd5, 0xed, 0xaf, 0x59, 0x5b, 0xc8, 0x43, 0xb8,
	0xeb, 0x25, 0xb1, 0xe6, 0x78, 0x2a, 0xc2, 0x60, 0x22, 0x34, 0x52, 0xc7, 0xf4, 0xfb, 0x17, 0x9b,
	0x0d, 0xda, 0x54, 0x3d, 0x9c, 0x1e, 0x28, 0x25, 0x15, 0x85, 0x7f, 0x18, 0x74, 0xd1, 0x48, 0xee,
	0x43, 0xe5, 0x55, 0x10, 0x6a, 0x54, 0xb4, 0x66, 0xd6, 0xbd, 0x46, 0xee, 0x37, 0x1b, 0x1c, 0xb3,
	0x0e, 0x0f, 0xb5, 0xc8, 0x32, 0x51, 0x88, 0x29, 0xcf, 0x01, 0x39, 0x80, 0xda, 0x50, 0xc4, 0x7a,
	0x20, 0x23, 0x2d, 0xc6, 0xda, 0x24, 0x62, 0xcb, 0x1e, 0x8a, 0x3e, 0xd2, 0x86, 0xda, 0x9b, 0x48,
	0x9e, 0x45, 0x43, 0x14, 0x13, 0x54, 0x26, 0x33, 0x55, 0x5e, 0xa4, 0xc8, 0x23, 0xd8, 0xb9, 0xde,
	0xe6, 0x78, 0x3e, 0xc4, 0x53, 0x0c, 0x4d, 0x26, 0x1c, 0xbe, 0xc1, 0xf7, 0xdb, 0x8b, 0x5f, 0xcc,
	0x5a, 0x2c, 0x99, 0x7d, 0xb1, 0x64, 0xf6, 0xcf, 0x25, 0xb3, 0xbf, 0xac, 0x98, 0x75, 0xbe, 0x62,
	0xd6, 0xc5, 0x8a, 0x59, 0xdf, 0x57, 0xcc, 0x1a, 0x55, 0x4c, 0x67, 0xcf, 0xfe, 0x04, 0x00, 0x00,
	0xff, 0xff, 0x1a, 0x53, 0x13, 0x02, 0xdb, 0x03, 0x00, 0x00,
}

func (m *RaftIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CreateIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.CreateIndex))
	}
	if m.ModifyIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.ModifyIndex))
	}
	return i, nil
}

func (m *WriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *QueryOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.MinQueryIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.MinQueryIndex))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxQueryTime)))
	n1, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MaxQueryTime, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.AllowStale {
		dAtA[i] = 0x20
		i++
		if m.AllowStale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RequireConsistent {
		dAtA[i] = 0x28
		i++
		if m.RequireConsistent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseCache {
		dAtA[i] = 0x30
		i++
		if m.UseCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxStaleDuration)))
	n2, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MaxStaleDuration, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x42
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxAge)))
	n3, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MaxAge, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.MustRevalidate {
		dAtA[i] = 0x48
		i++
		if m.MustRevalidate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.StaleIfError)))
	n4, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.StaleIfError, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.Filter) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	return i, nil
}

func (m *QueryMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStructs(dAtA, i, uint64(m.Index))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintStructs(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.LastContact)))
	n5, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.LastContact, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.KnownLeader {
		dAtA[i] = 0x18
		i++
		if m.KnownLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ConsistencyLevel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStructs(dAtA, i, uint64(len(m.ConsistencyLevel)))
		i += copy(dAtA[i:], m.ConsistencyLevel)
	}
	return i, nil
}

func encodeVarintStructs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RaftIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateIndex != 0 {
		n += 1 + sovStructs(uint64(m.CreateIndex))
	}
	if m.ModifyIndex != 0 {
		n += 1 + sovStructs(uint64(m.ModifyIndex))
	}
	return n
}

func (m *WriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *QueryOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	if m.MinQueryIndex != 0 {
		n += 1 + sovStructs(uint64(m.MinQueryIndex))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxQueryTime)
	n += 1 + l + sovStructs(uint64(l))
	if m.AllowStale {
		n += 2
	}
	if m.RequireConsistent {
		n += 2
	}
	if m.UseCache {
		n += 2
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxStaleDuration)
	n += 1 + l + sovStructs(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MaxAge)
	n += 1 + l + sovStructs(uint64(l))
	if m.MustRevalidate {
		n += 2
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.StaleIfError)
	n += 1 + l + sovStructs(uint64(l))
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func (m *QueryMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStructs(uint64(m.Index))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.LastContact)
	n += 1 + l + sovStructs(uint64(l))
	if m.KnownLeader {
		n += 2
	}
	l = len(m.ConsistencyLevel)
	if l > 0 {
		n += 1 + l + sovStructs(uint64(l))
	}
	return n
}

func sovStructs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStructs(x uint64) (n int) {
	return sovStructs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RaftIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateIndex", wireType)
			}
			m.CreateIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifyIndex", wireType)
			}
			m.ModifyIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifyIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQueryIndex", wireType)
			}
			m.MinQueryIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinQueryIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MaxQueryTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowStale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowStale = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireConsistent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireConsistent = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseCache = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStaleDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MaxStaleDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MaxAge, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustRevalidate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustRevalidate = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleIfError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.StaleIfError, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastContact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.LastContact, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnownLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KnownLeader = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsistencyLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsistencyLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStructs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStructs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStructs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStructs
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthStructs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStructs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStructs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthStructs
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStructs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStructs   = fmt.Errorf("proto: integer overflow")
)
